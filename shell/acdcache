#! /usr/bin/env python3
# ex: et sts=4 ts=4 sw=4

import sys
import os
import shutil
import hashlib

from acdcli.api import client as ACD
from acdcli.cache import db as DB
from acdcli.api.common import RequestError
from acdcli.utils import hashing
from acdcli.utils.time import datetime_to_timestamp


class Cache(object):

    def __init__(self, cache_folder):
        self._cache_folder = cache_folder
        auth_folder = os.path.expanduser('~/.cache/acd_cli')
        self._acd_client = ACD.ACDClient(auth_folder)
        self._acd_db = DB.NodeCache(auth_folder)
        self._last_recycle = 0

    def __call__(self, acd_path):
        folder = self._acd_db.resolve(acd_path)
        folders, files = self._acd_db.list_children(folder.id)
        children = folders + files
        children = sorted(children, key=lambda _: _.modified, reverse=True)
        for child in children:
            self._recycle_space()
            if self._is_too_old(child):
                break
            self._download(child, self._cache_folder)

    def _recycle_space(self):
        entries = self._get_cache_entries()

        while True:
            free_space = self._get_free_space()
            if free_space > 10:
                break

            full_path, mtime = entries.pop(0)
            if os.path.isdir(full_path):
                shutil.rmtree(full_path)
            else:
                os.remove(full_path)
            self._last_recycle = mtime
            print('recycled: ' + full_path)

    def _get_cache_entries(self):
        entries = os.listdir(self._cache_folder)
        entries = (os.path.join(self._cache_folder, _) for _ in entries)
        entries = ((_, os.stat(_).st_mtime) for _ in entries)
        entries = sorted(entries, key=lambda _: _[1])
        return entries

    def _get_free_space(self):
        s = os.statvfs(self._cache_folder)
        s = s.f_frsize * s.f_bavail
        s = s / 1024
        s = s / 1024 / 1024
        return s

    def _is_too_old(self, node):
        return datetime_to_timestamp(node.modified) < self._last_recycle

    def _download(self, node, local_path):
        local_path = local_path if local_path else ''
        full_path = os.path.join(local_path, node.name)

        if not node.is_available:
            return False

        if node.is_folder:
            ok = self._download_folder(node, full_path)
        else:
            ok = self._download_file(node, local_path, full_path)

        if not ok:
            return False

        ok = preserve_mtime(node, full_path)

        return ok

    def _download_folder(self, node, full_path):
        try:
            os.makedirs(full_path, exist_ok=True)
        except OSError:
            print('mkdir failed: ' + full_path)
            return False

        folders, files = self._acd_db.list_children(node.id)
        children = folders + files
        for child in children:
            ok = self._download(child, full_path)
            if not ok:
                return False

        return True

    def _download_file(self, node, local_path, full_path):
        if os.path.isfile(full_path):
            print('checking existed: ' + full_path)
            local = md5sum(full_path)
            remote = node.md5
            if local == remote:
                print('skip same file: ' + full_path)
                return True
            print('md5 mismatch: ' + full_path)
            os.remove(full_path)

        while True:
            hasher = hashing.IncrementalHasher()
            try:
                print('downloading: ' + full_path)
                self._acd_client.download_file(node.id, node.name, local_path, write_callbacks=[
                    hasher.update,
                ])
                print('downloaded: ' + full_path)
            except RequestError as e:
                print('download failed: ' + str(e))
            except OSError as e:
                if e.errno == 36:
                    print('warning: file name too long')
                    return True
                raise
            else:
                local = hasher.get_result()
                remote = node.md5
                if local != remote:
                    print('md5 mismatch: ' + full_path)
                    os.remove(full_path)
                else:
                    break

        return True


def main(args=None):
    if args is None:
        args = sys.argv

    dst_path = args[1]
    src_path = args[2:]

    cache = Cache(dst_path)
    for p in src_path:
        cache(p)

    return 0


def preserve_mtime(node, full_path):
    mtime = datetime_to_timestamp(node.modified)
    os.utime(full_path, (mtime, mtime))
    return True


def md5sum(full_path):
    hasher = hashlib.md5()
    with open(full_path, 'rb') as fin:
        while True:
            chunk = fin.read(65536)
            if not chunk:
                break
            hasher.update(chunk)
    return hasher.hexdigest()


if __name__ == '__main__':
    exit_code = main()
    sys.exit(exit_code)
